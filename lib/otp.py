#!/usr/bin/env python3

from base64 import urlsafe_b64encode, urlsafe_b64decode
from os import remove
from os.path import splitext, exists, basename, normpath, join, expanduser
from secrets import token_bytes
from time import time, ctime
from binascii import Error as BinasciiError
from gzip import (
    compress as gzip_compress,
    decompress as gzip_decompress
)
from zlib import (
    compress as zlib_compress,
    decompress as zlib_decompress,
    error as ZlibError
)
from lzma import (
    compress as lzma_compress,
    decompress as lzma_decompress,
    LZMAError
)
from bz2 import (
    compress as bz2_compress,
    decompress as bz2_decompress
)


def compress(message, mode="smallest"):
    """
    Given a bytes input `message` return the message using the
    algorithm set with `mode`
    """
    if mode == "smallest":
        compressed = []
        compressed.append(gzip_compress(message))
        compressed.append(zlib_compress(message))
        compressed.append(lzma_compress(message))
        compressed.append(bz2_compress(message))
        compressed.append(message)
        comp_len = [len(cmp) for cmp in compressed]
        comp_msg = compressed[comp_len.index(min(comp_len))]
    elif mode == "gzip":
        comp_msg = gzip_compress(message)
    elif mode == "zlib":
        comp_msg = zlib_compress(message)
    elif mode == "lzma":
        comp_msg = lzma_compress(message)
    elif mode == "bzip2":
        comp_msg = bz2_compress(message)
    else:  # uncompressed or otherwise invalid input
        comp_msg = message
    return comp_msg


def decompress(message):
    """
    Given a bytes input `message` return the decompressed message
    """
    try:
        return gzip_decompress(message)
    except OSError:
        pass
    try:
        return zlib_decompress(message)
    except ZlibError:
        pass
    try:
        return lzma_decompress(message)
    except LZMAError:
        pass
    try:
        return bz2_decompress(message)
    except OSError:
        pass
    return message


def generate_key(length):
    """
    Given an integer `length`, return a Base64-encoded key with that many
    randomly generated bytes
    """
    key = urlsafe_b64encode(token_bytes(length))
    return key


def encrypt(message, key, mode="smallest"):
    """
    Given a bytes input `message` and `key` in Base64, return an OTP-encoded
    message as a string
    """
    cmp = compress(message, mode)
    msg = urlsafe_b64encode(cmp)
    enc_str = ""
    for m, k in zip(msg, key):
        enc_str += chr(m ^ k)
    encrypted = urlsafe_b64encode(enc_str.encode("utf8")).decode("utf8")
    return encrypted.replace("=", "")


def decrypt(encrypted, key):
    """
    Given a bytes input `encrypted` and `key` in Base64, return the
    decrypted message as a string
    """
    if len(encrypted) % 4:  # addresses padding issue if necessary
        encrypted += b"=" * (4 - len(encrypted) % 4)
    encrypted = urlsafe_b64decode(encrypted)
    dec_str = ""
    for e, k in zip(encrypted, key):
        dec_str += chr(e ^ k)
    dec_str = dec_str.encode("utf8")
    if len(dec_str) % 4:  # addresses padding issue if necessary
        dec_str += b"=" * (4 - len(dec_str) % 4)
    decrypted = decompress(urlsafe_b64decode(dec_str))
    return decrypted


def bn(name):
    return basename(normpath(name))


def encrypt_file_name(file, enc_names=False, file_dir="", keys_dir=""):
    """
    Given a file as a string input, return an OTP-encoded
    file and corresponding key as a string and Base64,
    respectively
    """
    name = bn(file)
    key = generate_key(len(compress(name.encode("utf8"))))
    if enc_names:
        encrypted = encrypt(name.encode("utf8"), key, "uncompressed")
        enc_file = f"{join(file_dir, encrypted)}.otp"
    else:
        enc_file = f"{join(file_dir, name)}.otp"
    key = key.decode("utf8").replace("=", "")
    key_file = f"{join(keys_dir, key)}.key"
    return enc_file, key_file


def decrypt_file_name(file, key_file, file_dir=""):
    """
    Given a string file and corresponding key in Base64, return
    the decrypted file
    """
    if bn(file)[-4:] == ".otp":
        file_name = bn(file)[:-4].encode("utf8")
    else:
        file_name = bn(file).encode("utf8")
    key = bn(key_file[:-4]).encode("utf8")
    try:
        dec_file = decrypt(file_name, key).decode("utf8")
    except BinasciiError:
        dec_file = file_name.decode("utf8")
    dec_file = join(file_dir, dec_file)
    return dec_file


def encrypt_file(
    file,
    file_dir="",
    keys_dir="",
    mode="smallest",
    enc_names=False,
    del_toggle=False
):
    """
    Given a file, writes the encrypted message and corresponding
    key to separate files
    """
    msg = open(file, "rb").read()
    key = generate_key(len(compress(msg, mode)))
    encrypted = encrypt(msg, key, mode).encode("utf8")
    enc_file, key_file = encrypt_file_name(file, enc_names, file_dir, keys_dir)

    # write to files
    if len(encrypted) % 4:  # addresses padding issue if necessary
        encrypted += b"=" * (4 - len(encrypted) % 4)
    with open(enc_file, "wb") as e:
        e.write(urlsafe_b64decode(encrypted))
        e.close()
    with open(key_file, "wb") as k:
        k.write(urlsafe_b64decode(key))
        k.close()
    log = f"{file}\n{enc_file}\n{key_file}\n{ctime(time())}\n\n"
    log_file = join(expanduser("~"), ".footprint-otp", "otp.log")
    try:
        with open(log_file, "a") as logfile:
            logfile.write(log)
            logfile.close()
    except FileNotFoundError:
        with open(log_file, "w") as logfile:
            logfile.write(log)
            logfile.close()
    if del_toggle:
        remove(file)
    return enc_file, key_file


def decrypt_file(
    file,
    key_file,
    file_dir="",
    del_toggle=False
):
    """
    Given a file and key file, reads the encrypted message from
    file using the key from key_file
    """
    msg = urlsafe_b64encode(open(file, "rb").read())
    key = urlsafe_b64encode(open(key_file, "rb").read())
    decrypted = decrypt(msg, key)
    dec_file = decrypt_file_name(file, key_file, file_dir)
    if del_toggle:
        remove(file)
        remove(key_file)
        try:
            log_file = join(expanduser("~"), ".footprint-otp", "otp.log")
            old_log = open(log_file, "r").readlines()
            files = [bn(line[:-1]) for line in old_log]
            # find the index of the file name
            ind = files.index(bn(file)) - 1
            # designate the indices of the lines to be removed i.e. the file
            # and the four lines immediately following it
            rmv = []
            for i in range(5):
                rmv.append(ind + i)
            # updated log contains everything but the removed item
            new_log = [j for i, j in enumerate(old_log) if i not in rmv]
            with open(log_file, "w") as logfile:
                for line in new_log:
                    logfile.write(line)
                logfile.close()
        except ValueError:
            pass
    dec, ext = splitext(dec_file)
    if exists(f"{dec}{ext}"):
        i = 0
        while exists(f"{dec}({str(i)}){ext}"):
            i += 1
        dec_file = f"{dec}({str(i)}){ext}"
    with open(dec_file, "wb") as d:
        d.write(decrypted)
        d.close()
    return dec_file
